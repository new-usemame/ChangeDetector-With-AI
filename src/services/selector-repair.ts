import { openRouterService } from './openrouter';
import { cleanHtml, extractTextContent } from '../utils/html-parser';
import { logger } from '../utils/logger';

export interface SelectorRepairResult {
  selector: string | null;
  selectorType: 'css' | 'xpath' | null;
  confidence: number;
  explanation: string;
}

export class SelectorRepairService {
  async repairSelector(
    html: string,
    targetDescription: string,
    oldSelector?: string,
    selectorType: 'css' | 'xpath' = 'css'
  ): Promise<SelectorRepairResult> {
    try {
      logger.debug(`Repairing selector for: ${targetDescription}`);

      // Use AI to generate a new selector
      return await this.generateSelectorWithAI(html, targetDescription, oldSelector, selectorType);
    } catch (error) {
      logger.error('Error repairing selector:', error);
      return {
        selector: null,
        selectorType: null,
        confidence: 0,
        explanation: 'Failed to repair selector',
      };
    }
  }

  private async generateSelectorWithAI(
    html: string,
    targetDescription: string,
    oldSelector?: string,
    selectorType: 'css' | 'xpath' = 'css'
  ): Promise<SelectorRepairResult> {
    const cleanedHtml = cleanHtml(html);
    const textContent = extractTextContent(html, 20000); // Limit for selector generation

    const systemPrompt = `You are an expert at generating CSS and XPath selectors for web scraping.
Given HTML content and a description of what to find, generate a robust selector.

Return ONLY valid JSON in this exact format:
{
  "selector": "css-selector-or-xpath" or null,
  "selectorType": "css" or "xpath",
  "confidence": 0.0-1.0,
  "explanation": "Brief explanation of the selector"
}

Rules:
- Generate a selector that uniquely targets the described element
- Prefer CSS selectors unless XPath is necessary
- Use stable attributes (id, data-*, aria-*) over classes that might change
- Avoid overly specific selectors that break easily
- If the target cannot be found, return null for selector
- confidence: How certain you are this selector will work (0.0-1.0)
- explanation: Brief explanation of why this selector was chosen`;

    const userPrompt = `Generate a ${selectorType} selector for: "${targetDescription}"
${oldSelector ? `Previous selector (broken): ${oldSelector}` : ''}

HTML content (first 20000 chars):
${textContent}

Generate the best selector to target this element. Return the JSON response now:`;

    try {
      const response = await openRouterService.extractText([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ]);

      // Parse JSON from response
      let jsonStr = response.trim();
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/^```(?:json)?\n?/i, '').replace(/\n?```$/i, '');
      }

      const result = JSON.parse(jsonStr) as SelectorRepairResult;
      
      // Validate selector type
      const validSelectorType = result.selectorType === 'xpath' ? 'xpath' : 'css';
      
      return {
        selector: result.selector || null,
        selectorType: result.selector ? validSelectorType : null,
        confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
        explanation: result.explanation || 'Generated by AI',
      };
    } catch (error) {
      logger.error('Error parsing AI selector response:', error);
      return {
        selector: null,
        selectorType: null,
        confidence: 0,
        explanation: 'Failed to generate selector',
      };
    }
  }

  async detectBrokenSelector(
    html: string,
    selector: string,
    selectorType: 'css' | 'xpath' = 'css'
  ): Promise<boolean> {
    // Simple check: if selector returns nothing, it's likely broken
    // This is a basic check - in production, you'd use a proper HTML parser
    try {
      // For CSS selectors, check if the selector syntax is valid
      if (selectorType === 'css') {
        // Basic validation - check if selector contains common patterns
        if (!selector || selector.trim().length === 0) {
          return true;
        }
      }

      // For XPath, basic syntax check
      if (selectorType === 'xpath') {
        if (!selector || selector.trim().length === 0) {
          return true;
        }
        // XPath should start with // or / or contain @
        if (!selector.startsWith('//') && !selector.startsWith('/') && !selector.includes('@')) {
          // Might still be valid, but suspicious
          logger.warn(`XPath selector doesn't match common patterns: ${selector}`);
        }
      }

      return false;
    } catch (error) {
      logger.error('Error detecting broken selector:', error);
      return true; // Assume broken if we can't check
    }
  }
}

export const selectorRepairService = new SelectorRepairService();
